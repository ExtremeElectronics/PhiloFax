// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

#define PIN_OFFS_D0 0
#define PIN_OFFS_CLK 1
#define PIN_OFFS_VSYNC 2
#define PIN_OFFS_HREF 3
#define PIN_OFFS_PXCLK 4

// --------------------- //
// camera_pio_shift_byte //
// --------------------- //

#define camera_pio_shift_byte_wrap_target 0
#define camera_pio_shift_byte_wrap 7

static const uint16_t camera_pio_shift_byte_program_instructions[] = {
            //     .wrap_target
    0xe027, //  0: set    x, 7                       
    0x20d4, //  1: wait   1 irq, 4 rel               
    0x25a4, //  2: wait   1 pin, 4               [5] 
    0xb942, //  3: nop                    side 1 [1] 
    0x5001, //  4: in     pins, 1         side 0     
    0x1944, //  5: jmp    x--, 4          side 1 [1] 
    0x3024, //  6: wait   0 pin, 4        side 0     
    0xc004, //  7: irq    nowait 4                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program camera_pio_shift_byte_program = {
    .instructions = camera_pio_shift_byte_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config camera_pio_shift_byte_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + camera_pio_shift_byte_wrap_target, offset + camera_pio_shift_byte_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}

static inline pio_sm_config camera_pio_get_shift_byte_sm_config(PIO pio, uint sm, uint offset, uint base_pin, uint bpp)
{
    pio_sm_config c = camera_pio_shift_byte_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_in_shift(&c, true, true, bpp);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK);
    return c;
}

#endif

// ---------------- //
// camera_pio_frame //
// ---------------- //

#define camera_pio_frame_wrap_target 0
#define camera_pio_frame_wrap 17

#define camera_pio_frame_offset_loop_pixel 6u

static const uint16_t camera_pio_frame_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block                      
    0x6040, //  1: out    y, 32                      
    0x80a0, //  2: pull   block                      
    0x20a2, //  3: wait   1 pin, 2                   
    0xa027, //  4: mov    x, osr                     
    0x22a3, //  5: wait   1 pin, 3               [2] 
    0xc025, //  6: irq    wait 5                     
    0x20c4, //  7: wait   1 irq, 4                   
    0xc025, //  8: irq    wait 5                     
    0x20c4, //  9: wait   1 irq, 4                   
    0xc025, // 10: irq    wait 5                     
    0x20c4, // 11: wait   1 irq, 4                   
    0xc025, // 12: irq    wait 5                     
    0x20c4, // 13: wait   1 irq, 4                   
    0x0046, // 14: jmp    x--, 6                     
    0x2023, // 15: wait   0 pin, 3                   
    0x0084, // 16: jmp    y--, 4                     
    0xc020, // 17: irq    wait 0                     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program camera_pio_frame_program = {
    .instructions = camera_pio_frame_program_instructions,
    .length = 18,
    .origin = -1,
};

static inline pio_sm_config camera_pio_frame_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + camera_pio_frame_wrap_target, offset + camera_pio_frame_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}

static inline void camera_pio_init_gpios(PIO pio, uint sm, uint base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }
    pio->input_sync_bypass = (1 << (base_pin + PIN_OFFS_D0));
}
static inline pio_sm_config camera_pio_get_frame_sm_config(PIO pio, uint sm, uint offset, uint base_pin)
{
    pio_sm_config c = camera_pio_frame_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_out_shift(&c, true, false, 0);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK);
    return c;
}
static inline bool camera_pio_frame_done(PIO pio)
{
    return pio_interrupt_get(pio, 0);
}
static inline void camera_pio_wait_for_frame_done(PIO pio)
{
    while (!camera_pio_frame_done(pio));
}
static inline void camera_pio_trigger_frame(PIO pio, uint32_t cols, uint32_t rows)
{
    pio_interrupt_clear(pio, 0);
    pio_sm_put_blocking(pio, 0, rows - 1);
    pio_sm_put_blocking(pio, 0, cols - 1);
}

#endif

// --------------- //
// pixel_loop_yuyv //
// --------------- //

#define pixel_loop_yuyv_wrap_target 0
#define pixel_loop_yuyv_wrap 7

static const uint16_t pixel_loop_yuyv_program_instructions[] = {
            //     .wrap_target
    0xc025, //  0: irq    wait 5                     
    0x20c4, //  1: wait   1 irq, 4                   
    0xc025, //  2: irq    wait 5                     
    0x20c4, //  3: wait   1 irq, 4                   
    0xc025, //  4: irq    wait 5                     
    0x20c4, //  5: wait   1 irq, 4                   
    0xc025, //  6: irq    wait 5                     
    0x20c4, //  7: wait   1 irq, 4                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pixel_loop_yuyv_program = {
    .instructions = pixel_loop_yuyv_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config pixel_loop_yuyv_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + pixel_loop_yuyv_wrap_target, offset + pixel_loop_yuyv_wrap);
    return c;
}
#endif

// ----------------- //
// pixel_loop_rgb565 //
// ----------------- //

#define pixel_loop_rgb565_wrap_target 0
#define pixel_loop_rgb565_wrap 7

static const uint16_t pixel_loop_rgb565_program_instructions[] = {
            //     .wrap_target
    0xc025, //  0: irq    wait 5                     
    0x20c4, //  1: wait   1 irq, 4                   
    0xc025, //  2: irq    wait 5                     
    0x20c4, //  3: wait   1 irq, 4                   
    0xa042, //  4: nop                               
    0xa042, //  5: nop                               
    0xa042, //  6: nop                               
    0xa042, //  7: nop                               
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pixel_loop_rgb565_program = {
    .instructions = pixel_loop_rgb565_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config pixel_loop_rgb565_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + pixel_loop_rgb565_wrap_target, offset + pixel_loop_rgb565_wrap);
    return c;
}
#endif

// --------------- //
// pixel_loop_nv16 //
// --------------- //

#define pixel_loop_nv16_wrap_target 0
#define pixel_loop_nv16_wrap 7

static const uint16_t pixel_loop_nv16_program_instructions[] = {
            //     .wrap_target
    0xc025, //  0: irq    wait 5                     
    0x20c4, //  1: wait   1 irq, 4                   
    0xc026, //  2: irq    wait 6                     
    0x20c4, //  3: wait   1 irq, 4                   
    0xc025, //  4: irq    wait 5                     
    0x20c4, //  5: wait   1 irq, 4                   
    0xc026, //  6: irq    wait 6                     
    0x20c4, //  7: wait   1 irq, 4                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pixel_loop_nv16_program = {
    .instructions = pixel_loop_nv16_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config pixel_loop_nv16_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + pixel_loop_nv16_wrap_target, offset + pixel_loop_nv16_wrap);
    return c;
}
#endif

// --------------- //
// pixel_loop_yu16 //
// --------------- //

#define pixel_loop_yu16_wrap_target 0
#define pixel_loop_yu16_wrap 7

static const uint16_t pixel_loop_yu16_program_instructions[] = {
            //     .wrap_target
    0xc025, //  0: irq    wait 5                     
    0x20c4, //  1: wait   1 irq, 4                   
    0xc026, //  2: irq    wait 6                     
    0x20c4, //  3: wait   1 irq, 4                   
    0xc025, //  4: irq    wait 5                     
    0x20c4, //  5: wait   1 irq, 4                   
    0xc027, //  6: irq    wait 7                     
    0x20c4, //  7: wait   1 irq, 4                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pixel_loop_yu16_program = {
    .instructions = pixel_loop_yu16_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config pixel_loop_yu16_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + pixel_loop_yu16_wrap_target, offset + pixel_loop_yu16_wrap);
    return c;
}

static inline void camera_pio_patch_pixel_loop(PIO pio, uint offset, const pio_program_t *loop) {
    uint i;
    // TODO: Assert that length of program is 8?
    for (i = 0; i < loop->length; i++) {
        pio->instr_mem[offset + camera_pio_frame_offset_loop_pixel + i] = loop->instructions[i];
    }
}

#endif

